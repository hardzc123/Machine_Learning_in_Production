# Machine_Learning_in_Production
Engineering, Optimization, Automation, Scaling

This repo reveals my insights about how industry-level AI should be considered and implemented

Topics might include: 
1. Linux / Bash
2. Software Engineering
3. Data Engineering
4. MLOps
5. Embedded AI
6. Distributed System
7. Cloud service provider
8. Multi-Agent
9. AI Products

[Reference] https://developers.google.com/machine-learning/crash-course/production-ml-systems

Real-world production ML system:
1. ML Model code (less than 5%)
2. Data collection
3. Data verification
4. Machine resource management
5. Feature extraction
6. Analysis tools
7. Serving ingrastructure
8. Process management tools
9. Configuration
10. Monitoring


ML Pipelines: 
Without pipelines, replacing a stale model is an error-prone process. For example, once a model starts serving bad predictions, someone will need to manually collect and process new data, train a new model, validate its quality, and then finally deploy it. ML pipelines automate many of these repetitive processes, making the management and maintenance of models more efficient and reliable.

The following pipelines work together to train a new model:

Data pipeline. The data pipeline processes user data to create training and test datasets.
Training pipeline. The training pipeline trains models using the new training datasets from the data pipeline.
Validation pipeline. The validation pipeline validates the trained model by comparing it with the production model using test datasets generated by the data pipeline.

dynamic training VS static training


https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning

MLOps


pytorch in 100 seconds
https://youtu.be/ORMx45xqWkA?si=c9-8SxsuOvaGjBYc

deeplearning crash course
https://youtu.be/VyWAvY2CF9c?si=fBwhqxnxvCARoX4z


## Software Engineering (now also powered by LLM)
1. Always Design first before Development, KISS Principle, YAGNI, DRY 
2. Code Readability
3. Code Performance Optimization in Runtime, MVP, Agile, avoid premuture optimization
5. Version Control
6. Dependency management, virutal environment 
7. Data Serialization and Configuration Development
8. Testing / Automatic Testing (CICD, Regression Testing)
9. Software Design Patterns
10. Documentation
11. Code Review
12. Postmotem


### Version Control
```bash
# common git commands
git ....


```
Branch management: 

- dev
- test
- master
- feature
- hotfix

Semantic Versioning: https://semver.org/ ( created by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.)


https://www.conventionalcommits.org/en/v1.0.0/

